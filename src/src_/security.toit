// Copyright (C) 2024 Toitware ApS.
// Use of this source code is governed by an MIT-style license that can be
// found in the package's LICENSE file.

import crypto.aes show AesGcm
import io
import protobuf
import ..provision
import ..proto_.session-pb
import ..proto_.sec0-pb
import ..proto_.sec2-pb
import ..proto_.constants-pb
import ..srp

class SecurityCredentials:
  salt/ByteArray
  verifier/ByteArray

  constructor.scheme2 --.salt/ByteArray --.verifier/ByteArray:

security-for --credentials/SecurityCredentials? -> Security:
  if not credentials: return Security0_
  return Security2_ credentials.salt credentials.verifier

interface Security:
  encrypt data/ByteArray -> ByteArray
  decrypt data/ByteArray -> ByteArray
  handle-handshake-request data/ByteArray -> protobuf.Message
  version -> int

/**
Security scheme 0 doesn't encrypt/decrypt.

See https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/provisioning/provisioning.html#security-schemes.
*/
class Security0_ implements Security:

  handle-handshake-request data/ByteArray -> protobuf.Message:
    session := SessionData.deserialize (protobuf.Reader data)

    if session.sec-ver != version:
      throw "Session version does not match"

    ses0 := session.proto-sec0
    if ses0.msg == Sec0MsgType-S0-Session-Command:
      return SessionData
          --sec-ver=version
          --proto-sec0=Sec0Payload
              --msg=Sec0MsgType-S0-Session-Response
              --payload-sr=S0SessionResp
                  --status=Status-Success
    else:
      throw "Session 0 message is not supported"

  encrypt data/ByteArray -> ByteArray:
    return data

  decrypt data/ByteArray -> ByteArray:
    return data

  version -> int:
    return SecSchemeVersion-SecScheme0

/**
Security scheme 2 uses SRP6a + AES-GCM.

See https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/provisioning/provisioning.html#security-2-scheme.

Secure Remote Password protocol RP6a: https://datatracker.ietf.org/doc/html/rfc5054.
*/
class Security2_ implements Security:
  salt_/ByteArray

  srp_/SRP
  session-key_/ByteArray := #[]
  user-name_/ByteArray := #[]
  // TODO(florian): use a cryptographic random function.
  aes-gcm-iv_/ByteArray := ByteArray 12: random

  constructor .salt_/ByteArray verifier/ByteArray:
    srp_ = SRP salt_ verifier

  handle-handshake-request data/ByteArray -> protobuf.Message:
    session := SessionData.deserialize (protobuf.Reader data)

    if session.sec-ver != version:
      throw "Session version does not match"

    ses2 := session.proto-sec2
    if ses2.msg == Sec2MsgType-S2Session-Command0:
      user-name_ = ses2.payload-sc0.client-username
      session-key_ = srp_.get-session-key ses2.payload-sc0.client-pubkey

      return SessionData
          --sec-ver=version
          --proto-sec2=Sec2Payload
              --msg=Sec2MsgType-S2Session-Response0
              --payload-sr0=S2SessionResp0
                  --status=Status-Success
                  --device-pubkey=srp_.gen-service-public-key
                  --device-salt=salt_

    if ses2.msg == Sec2MsgType-S2Session-Command1:
      device-proof/ByteArray? := null
      exception := catch:
        device-proof = srp_.exchange-proofs user-name_ ses2.payload-sc1.client-proof

      if exception:
        return SessionData
            --sec-ver=version
            --proto-sec2=Sec2Payload
                --msg=Sec2MsgType-S2Session-Response1
                --payload-sr1=S2SessionResp1
                    --status=Status-CryptoError

      return SessionData
          --sec-ver=version
          --proto-sec2=Sec2Payload
              --msg=Sec2MsgType-S2Session-Response1
              --payload-sr1=S2SessionResp1
                  --status=Status-Success
                  --device-proof=device-proof
                  --device-nonce=aes-gcm-iv_
    else:
      throw "Session 2 message is not supported"

  encrypt data/io.Data -> io.Data:
    //  The session_key_ is generated by SHA512, so its length is 512
    // bits(64 bytes), but AES-GCM's key length is 256 bits(32 bytes).
    return (AesGcm.encryptor session-key_[..32] aes-gcm-iv_).encrypt data

  decrypt data/ByteArray -> ByteArray:
    return (AesGcm.decryptor session-key_[..32] aes-gcm-iv_).decrypt data

  version -> int:
    return SecSchemeVersion-SecScheme2

