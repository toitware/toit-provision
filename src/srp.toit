// Copyright (C) 2023 Toitware ApS.
// Use of this source code is governed by an MIT-style license that can be
// found in the package's LICENSE file.

import bignum show *
import crypto.sha show *

class SRP:
  static N_3072 ::= #[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
                      0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
                      0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
                      0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
                      0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
                      0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
                      0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
                      0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
                      0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
                      0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
                      0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
                      0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
                      0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
                      0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
                      0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
                      0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,
                      0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,
                      0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,
                      0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,
                      0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,
                      0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,
                      0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,
                      0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,
                      0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x3A, 0xD2, 0xCA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  static G_3072 ::= #[5]
  static n_::= Bignum.with_bytes false N_3072
  static g_::= Bignum.with_bytes false G_3072

  s_/Bignum
  v_/Bignum
  B_/Bignum
  b_/Bignum

  A_/Bignum? := null 
  session_key_/ByteArray := #[]

  constructor.with_random salt/ByteArray verifier/ByteArray random_data/ByteArray:
    if random_data.size != 32:
      throw "Random size must be 32 bytes"

    s_ = Bignum.with_bytes false salt
    v_ = Bignum.with_bytes false verifier
    b_ = Bignum.with_bytes false random_data

    k := gen_padded_hash_ N_3072 G_3072

    kv := (k * v_) % n_
    gb := mod_exp g_ b_ n_
    B_  = (kv + gb) % n_
  
  constructor salt/ByteArray verifier/ByteArray:
    random_data := ByteArray 32: random
    return SRP.with_random salt verifier random_data

  static gen_padded_hash_ a/ByteArray b/ByteArray -> Bignum:
    n := N_3072.size
    pad_size := a.size > b.size ? n - b.size : n - a.size
    pad := pad_size > 0 ? ByteArray pad_size: null
    
    digest_sha := Sha512
    if pad and a.size != n:
      digest_sha.add pad 0 (n - a.size)
    digest_sha.add a

    if pad and b.size != n:
      digest_sha.add pad 0 (n - b.size)
    digest_sha.add b

    return Bignum.with_bytes false digest_sha.get

  gen_service_public_key -> ByteArray:
    return B_.limbs_

  get_session_key public_key/ByteArray -> ByteArray:
    A_ = Bignum.with_bytes false public_key
    u := gen_padded_hash_ public_key B_.limbs_

    vu := mod_exp v_ u n_
    avu := (A_ * vu) % n_
    S := mod_exp avu b_ n_
    session_key_ = sha512 S.limbs_

    return session_key_

  exchange_proofs user_name/ByteArray user_proof/ByteArray -> ByteArray:
    SHA512_SIZE := 64
    user_name_hash := sha512 user_name
    n_hash := sha512 N_3072

    pad_len := N_3072.size - G_3072.size
    pad := ByteArray pad_len

    g_sha := Sha512
    g_sha.add pad
    g_sha.add G_3072
    g_hash := g_sha.get

    bash_n_xor_g := ByteArray SHA512_SIZE
    SHA512_SIZE.repeat:
      bash_n_xor_g[it] = n_hash[it] ^ g_hash[it]

    cal_user_proof_sha := Sha512
    cal_user_proof_sha.add bash_n_xor_g
    cal_user_proof_sha.add user_name_hash
    cal_user_proof_sha.add s_.limbs_
    cal_user_proof_sha.add A_.limbs_
    cal_user_proof_sha.add B_.limbs_
    cal_user_proof_sha.add session_key_
    cal_user_proof := cal_user_proof_sha.get
    if cal_user_proof != user_proof:
      throw "user_proof is not right"

    host_proof_sha := Sha512
    host_proof_sha.add A_.limbs_
    host_proof_sha.add user_proof
    host_proof_sha.add session_key_
    host_proof := host_proof_sha.get

    return host_proof
