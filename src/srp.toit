// Copyright (C) 2023 Toitware ApS.
// Use of this source code is governed by an MIT-style license that can be
// found in the package's LICENSE file.

/**
An implementation of the Secure Remote Password protocol.

SRP is a password authenticated key-exchange where the client proves that it knows
the key without ever sending it to the server. In fact, the server itself doesn't know the
password.
*/

import bignum show *
import crypto.sha show *

class SRP:
  static N-3072 ::= #[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
                      0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
                      0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
                      0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
                      0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
                      0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
                      0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
                      0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
                      0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
                      0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
                      0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
                      0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
                      0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
                      0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
                      0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
                      0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,
                      0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,
                      0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,
                      0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,
                      0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,
                      0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,
                      0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,
                      0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,
                      0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x3A, 0xD2, 0xCA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  static G-3072 ::= #[5]
  static n_::= Bignum.with-bytes false N-3072
  static g_::= Bignum.with-bytes false G-3072

  s_/Bignum
  v_/Bignum
  B_/Bignum
  b_/Bignum

  A_/Bignum? := null 
  session-key_/ByteArray := #[]

  constructor.with-random salt/ByteArray verifier/ByteArray random-data/ByteArray:
    if random-data.size != 32:
      throw "Random size must be 32 bytes"

    s_ = Bignum.with-bytes false salt
    v_ = Bignum.with-bytes false verifier
    b_ = Bignum.with-bytes false random-data

    k := gen-padded-hash_ N-3072 G-3072

    kv := (k * v_) % n_
    gb := mod-exp g_ b_ n_
    B_  = (kv + gb) % n_
  
  constructor salt/ByteArray verifier/ByteArray:
    random-data := ByteArray 32: random
    return SRP.with-random salt verifier random-data

  static gen-padded-hash_ a/ByteArray b/ByteArray -> Bignum:
    n := N-3072.size
    pad-size := a.size > b.size ? n - b.size : n - a.size
    pad := pad-size > 0 ? ByteArray pad-size: null
    
    digest-sha := Sha512
    if pad and a.size != n:
      digest-sha.add pad 0 (n - a.size)
    digest-sha.add a

    if pad and b.size != n:
      digest-sha.add pad 0 (n - b.size)
    digest-sha.add b

    return Bignum.with-bytes false digest-sha.get

  gen-service-public-key -> ByteArray:
    return B_.limbs_

  get-session-key public-key/ByteArray -> ByteArray:
    A_ = Bignum.with-bytes false public-key
    u := gen-padded-hash_ public-key B_.limbs_

    vu := mod-exp v_ u n_
    avu := (A_ * vu) % n_
    S := mod-exp avu b_ n_
    session-key_ = sha512 S.limbs_

    return session-key_

  exchange-proofs user-name/ByteArray user-proof/ByteArray -> ByteArray:
    SHA512-SIZE := 64
    user-name-hash := sha512 user-name
    n-hash := sha512 N-3072

    pad-len := N-3072.size - G-3072.size
    pad := ByteArray pad-len

    g-sha := Sha512
    g-sha.add pad
    g-sha.add G-3072
    g-hash := g-sha.get

    bash-n-xor-g := ByteArray SHA512-SIZE
    SHA512-SIZE.repeat:
      bash-n-xor-g[it] = n-hash[it] ^ g-hash[it]

    cal-user-proof-sha := Sha512
    cal-user-proof-sha.add bash-n-xor-g
    cal-user-proof-sha.add user-name-hash
    cal-user-proof-sha.add s_.limbs_
    cal-user-proof-sha.add A_.limbs_
    cal-user-proof-sha.add B_.limbs_
    cal-user-proof-sha.add session-key_
    cal-user-proof := cal-user-proof-sha.get
    if cal-user-proof != user-proof:
      throw "user_proof is not right"

    host-proof-sha := Sha512
    host-proof-sha.add A_.limbs_
    host-proof-sha.add user-proof
    host-proof-sha.add session-key_
    host-proof := host-proof-sha.get

    return host-proof
